= libUtils User's Guide
David Hao
:toc:
:toclevels: 4
:toc-position: left
:source-highlighter: pygments
:icons: font
:sectnums:

== libUtils 介绍

TIP: LibUtils 是想把qnx系统API做一个统一封装，实现模块标准化调用。目前，暂时只实现了共享内存的封装.
libUtils以动态库形式加载系统中。

* libUtils所在我们项目的目录
** #*PerformanceMCU\Source\Adapt\Libs\libUtils*#

== external API in libUtils.so

=== API list

[source,c]
----
* int32_t libUtils_MunmapShareMem(void* pvShareMemAddress,size_t size);

* int32_t libUtils_DestroyShareMem(const char*pcShareMemName);

* void * libUtils_ShareMemOpenReadWrite(const char* pcShareMemName,size_t size);

* void * libUtils_ShareMemOpenReadOnly(const char* pcShareMemName,size_t size);

* void * libUtils_ShareMemCreateForPrivate(const char* pcShareMemName, size_t size);

* void * libUtils_ShareMemCreateReadWrite(const char* pcShareMemName,size_t size);

* void * libUtils_ShareMemCreateReadWriteCheck(const char* pcShareMemName, size_t size);

* int32_t libUtils_CheckShareMemExist(const char* pcShareMemName)

* char * libutils_getSysErrstr(void);

* int32_t libutils_getSysErrno(void);
----

=== Detail information

==== Create a share memory

* #void * libUtils_ShareMemCreateReadWrite(const char* pcShareMemName,size_t size);#
** 创建一个share memroy，可读可写。创建过程不关心此share memory是否已经存在。
*** 入参
**** const char* pcShareMemName：要创建的sharememory名字，在qnx上通常为 #/name# 形式
**** size : 要创建的sharememory大小，注意，大于0
*** 返回值： void *
**** NULL: 创建失败
**** void *: 一个void类型指针，指向所创建sahre memroy地址

* #void * libUtils_ShareMemCreateReadWriteCheck(const char* pcShareMemName, size_t size);#
** 创建一个share memroy，可读可写。创建过程不关心此share memory是否已经存在。
*** 入参
**** const char* pcShareMemName：要创建的sharememory名字，在qnx上通常为 #/name# 形式
**** size : 要创建的sharememory大小，注意，大于0
*** 返回值： void *
**** NULL: 创建失败
**** void *: 一个void类型指针，指向所创建sahre memroy地址


....
以上是自己的一点总结
....
